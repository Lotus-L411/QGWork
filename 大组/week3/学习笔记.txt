一、排序算法核心总结
1.插入排序（InsertSort）
	思想：将元素逐个插入已排序序列的合适位置。
	时间复杂度：	
	最优：O(n)（已有序）
	最差：O(n²)（逆序）
	特点：稳定，适合小规模数据。

2.归并排序（MergeSort）
	思想：分治法，递归拆分后合并有序子序列。
	时间复杂度：O(n log n)（所有情况）
	特点：稳定，需额外空间，适合链表排序。
	
3.快速排序（QuickSort）
	思想：选定基准值分区，递归排序子序列。
	时间复杂度：
	平均：O(n log n)
	最差：O(n²)（基准选择不当）
	特点：不稳定，原地排序，实际应用高效。

4.计数排序（CountSort）
	思想：统计元素频次，按频次重建数组。
	时间复杂度：O(n + k)（k为值域范围）
	特点：非比较排序，适合值域小的整数。

5.基数排序（RadixCountSort）
	思想：按位数逐位排序（从低位到高位）。
	时间复杂度：O(d(n + k))（d为最大位数）
	特点：稳定，适合多位数排序。
二、性能对比实验
算法	10,000数据耗时	50,000数据耗时	200,000数据耗时
插入排序	0.12s	         3.01s	         48.7s (超慢)
归并排序	0.03s         0.15s	         0.62s
快速排序	0.02s        	0.09s         	0.38s
计数排序	0.01s 	0.04s          	0.17s
基数排序	0.02s 	0.08s              	0.31s
结论：
	小数据量：插入排序简单有效。
	大数据量：快速排序、基数排序表现最佳。
	值域有限：计数排序碾压其他算法。







